{"ast":null,"code":"import { NMatrix } from \"./matrices\";\nimport { Side } from \"./3dtypes\";\nexport class Event3DManager {\n  constructor(grid) {\n    this.sets = [];\n    this.sets = [];\n    this.grid = grid;\n  }\n  add(asset, col, floor, row) {\n    const newasset = asset.clone();\n    let allowedPosition = true;\n    // verify if there a set created\n    this.sets.forEach(set => {\n      if (set.hasAssetInPosition(col, floor, row)) {\n        throw new Error(\"There is already an asset is the position selected\");\n      } else {\n        newasset.x = col;\n        newasset.y = floor;\n        newasset.z = row;\n        // create a new set in the position selected.\n        let allowedPosition = true;\n      }\n    });\n    if (allowedPosition) {\n      const newSet = new Set(\"Set\" + this.sets.length, this.grid, newasset);\n      this.addSet(newSet);\n    }\n  }\n  addSet(set) {\n    this.sets.push(set);\n  }\n  // DEBUGGING FUNCTION delete when no needed and create it for the unit tests class.\n  printAssets() {\n    //console.log(this.assets);\n    const arr = this.sets[0].matrix.matrix;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        // Check if the row is defined\n        for (let j = 0; j < arr[i].length; j++) {\n          for (let k = 0; k < arr[i][j].length; k++) {\n            if (arr[i][j][k]) {\n              console.log(`[${i}][${j}][${k}] = ${arr[i][j][k].id}`);\n            }\n          }\n        }\n      }\n    }\n  }\n  // debug function. Delete when no needed.\n  render(scene) {\n    // render all the assets in the scene.\n    for (let i = 0; i < this.sets.length; i++) {\n      const set = this.sets[i];\n      console.log(set);\n      const arr = set.matrix.matrix;\n      for (let i = 0; i < arr.length; i++) {\n        if (arr[i]) {\n          // Check if the row is defined\n          for (let j = 0; j < arr[i].length; j++) {\n            for (let k = 0; k < arr[i][j].length; k++) {\n              if (arr[i][j][k] !== null) {\n                // render the asset\n                set.placeAsset(arr[i][j][k], i, j, k, this.grid, scene);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\nexport var Direction;\n(function (Direction) {\n  Direction[\"FRONT\"] = \"front\";\n  Direction[\"BACK\"] = \"back\";\n  Direction[\"LEFT\"] = \"left\";\n  Direction[\"RIGHT\"] = \"right\";\n})(Direction || (Direction = {}));\nconst directionMap = {\n  [Direction.FRONT]: {\n    x: 1,\n    z: 0\n  },\n  [Direction.BACK]: {\n    x: -1,\n    z: 0\n  },\n  [Direction.LEFT]: {\n    x: 0,\n    z: -1\n  },\n  [Direction.RIGHT]: {\n    x: 0,\n    z: 1\n  }\n};\nfunction updateNewPosition(direction, indx, indz) {\n  if (direction) {\n    indx += directionMap[direction].x;\n    indz += directionMap[direction].z;\n  }\n  return {\n    indx,\n    indz\n  };\n}\nexport class Set {\n  constructor(name, grid, initialAsset) {\n    this.name = name;\n    this.matrix = new NMatrix(grid.cols, grid.floor, grid.rows, null);\n    if (initialAsset) {\n      this.matrix.matrix[initialAsset.x][initialAsset.y][initialAsset.z] = initialAsset;\n    }\n    this.sideMatrix = new NMatrix(grid.cols, grid.floor, grid.rows, {\n      loc1: Side.CENTER,\n      loc2: Side.BOTTOM\n    });\n  }\n  add(oldasset) {\n    if (this.matrix.matrix[oldasset.col][oldasset.floor][oldasset.row] === null) {\n      throw new Error('The asset is not in the grid');\n    }\n    if (oldasset.direction1 === oldasset.direction2) {\n      throw new Error('Direction1 and Direction2 cannot be the same');\n    }\n    let newasset;\n    newasset = this.matrix.matrix[oldasset.col][oldasset.floor][oldasset.row].clone();\n    if (oldasset.gap) {\n      throw new Error('The gap is not implemented yet');\n      // logic for when there is a gap. I will put this to further into the project because it take a little bit more effort, but it would cool to be able to get out of the grid to acommodate the assets based on some custom gap.\n    } else {\n      let indx = newasset.x;\n      let indz = newasset.z;\n      ({\n        indx,\n        indz\n      } = updateNewPosition(oldasset.direction1, indx, indz));\n      if (oldasset.direction2) ({\n        indx,\n        indz\n      } = updateNewPosition(oldasset.direction2, indx, indz));\n      if (indx < 0 || indx >= this.matrix.cols || indz < 0 || indz >= this.matrix.rows) {\n        throw new Error('The asset is out of the grid');\n      }\n      // here we update the x and y according to the new position. This can be improved by restructuring what has the resopnsability to update the position. Because one can forget to update the x and y of the asset.\n      newasset.x = indx;\n      newasset.z = indz;\n      this.matrix.matrix[indx][newasset.y][indz] = newasset;\n      this.matrix.matrix[indx][newasset.y][indz].x = indx;\n      this.matrix.matrix[indx][newasset.y][indz].z = indz;\n      return this.getAsset(indx, newasset.y, indz);\n    }\n  }\n  getAsset(x, y, z) {\n    return this.matrix.matrix[x][y][z];\n  }\n  placeAsset(asset, x, y, z, grid, scene) {\n    grid.placeAssetTo(asset, x, y, z, this.sideMatrix.matrix[x][y][z].loc1, this.sideMatrix.matrix[x][y][z].loc2);\n    scene.add(asset.content);\n  }\n  hasAssetInPosition(x, y, z) {\n    let occupiedByAsset = false;\n    this.matrix.forEach((value, _i, _j, _k) => {\n      if (value !== null && value.x === x && value.y === y && value.z === z) {\n        occupiedByAsset = true;\n      }\n    });\n    return occupiedByAsset;\n  }\n}\nexport class ChairSet extends Set {\n  constructor(name, grid, initialChair) {\n    if (initialChair) {\n      super(name, grid, initialChair);\n    } else {\n      super(name, grid);\n    }\n  }\n  // remove the scene from the parameters. The final rendering should be set in another function. \n  placeAsset(asset, x, y, z, grid, scene) {\n    grid.placeAssetTo(asset, x, y, z, this.sideMatrix.matrix[x][y][z].loc1, this.sideMatrix.matrix[x][y][z].loc2);\n    scene.add(asset.content);\n  }\n  add(oldasset) {\n    // add the logic for the gap.\n    const result = super.add(oldasset);\n    if (result.size.width > oldasset.grid.width / oldasset.grid.cols || result.size.depth > oldasset.grid.depth / oldasset.grid.rows) {\n      if (oldasset.col === 0 && (oldasset.direction1 === Direction.FRONT || oldasset.direction2 === Direction.FRONT)) {\n        this.sideMatrix.change({\n          loc1: Side.BOTTOM,\n          loc2: Side.BACK\n        });\n      }\n      const assetwidth = result.size.width;\n      const assetdepth = result.size.depth;\n      this.matrix.matrix[result.x][result.y][result.z] = null;\n      const offsetx = Math.floor(assetwidth / (oldasset.grid.width / oldasset.grid.cols));\n      const offsetz = Math.floor(assetdepth / (oldasset.grid.depth / oldasset.grid.rows));\n      let x = result.x;\n      if (oldasset.direction1 === Direction.FRONT || oldasset.direction2 === Direction.FRONT) {\n        x = result.x + offsetx;\n      }\n      const z = result.z + offsetz;\n      // here we update the x and y according to the new position. This can be improved by restructuring what has the resopnsability to update the position. Because one can forget to update the x and y of the asset.\n      result.x = x;\n      result.z = z;\n      this.matrix.matrix[x][oldasset.floor][z] = result.clone();\n      return result;\n    }\n    //result!.content.scale.set(0.34, 1, 1);\n    return null;\n  }\n}","map":{"version":3,"names":["NMatrix","Side","Event3DManager","constructor","grid","sets","add","asset","col","floor","row","newasset","clone","allowedPosition","forEach","set","hasAssetInPosition","Error","x","y","z","newSet","Set","length","addSet","push","printAssets","arr","matrix","i","j","k","console","log","id","render","scene","placeAsset","Direction","directionMap","FRONT","BACK","LEFT","RIGHT","updateNewPosition","direction","indx","indz","name","initialAsset","cols","rows","sideMatrix","loc1","CENTER","loc2","BOTTOM","oldasset","direction1","direction2","gap","getAsset","placeAssetTo","content","occupiedByAsset","value","_i","_j","_k","ChairSet","initialChair","result","size","width","depth","change","assetwidth","assetdepth","offsetx","Math","offsetz"],"sources":["C:\\Users\\v-zacharyhe\\Documents\\GitHub\\eventhub\\frontend\\src\\app\\test\\event3dmanager.ts"],"sourcesContent":["import { EventType } from \"@angular/router\";\r\nimport { ThreeDObject } from \"../models/threeobject.model\";\r\nimport { EventGrid } from \"./events\";\r\nimport { Chair } from \"../models/chair.model\";\r\nimport { NMatrix } from \"./matrices\";\r\nimport { Side } from \"./3dtypes\";\r\nimport * as THREE from 'three';\r\nimport { Asset } from \"../interfaces\";\r\n\r\nexport class Event3DManager {\r\n    sets: Set[] = [];\r\n    grid: EventGrid;\r\n\r\n    constructor(grid: EventGrid) {\r\n        this.sets = [];\r\n        this.grid = grid;\r\n    }\r\n\r\n    add(asset: Asset, col: number, floor: number, row: number) {\r\n        const newasset = asset.clone();\r\n\r\n        let allowedPosition = true;\r\n        // verify if there a set created\r\n        this.sets.forEach((set) => {\r\n            if (set.hasAssetInPosition(col, floor, row)) {\r\n                throw new Error(\"There is already an asset is the position selected\");\r\n            }\r\n\r\n            else {\r\n\r\n                newasset.x = col;\r\n                newasset.y = floor;\r\n                newasset.z = row;\r\n                // create a new set in the position selected.\r\n                let allowedPosition = true;\r\n            }\r\n        });\r\n\r\n        if (allowedPosition) {\r\n            const newSet = new Set(\"Set\" + this.sets.length, this.grid, newasset);\r\n            this.addSet(newSet);\r\n        }\r\n    }\r\n\r\n    public addSet(set: Set) {\r\n        this.sets.push(set);\r\n    }\r\n\r\n    // DEBUGGING FUNCTION delete when no needed and create it for the unit tests class.\r\n    public printAssets() {\r\n        //console.log(this.assets);\r\n        const arr = this.sets[0].matrix.matrix;\r\n        for (let i = 0; i < arr.length; i++) {\r\n            if (arr[i]) { // Check if the row is defined\r\n                for (let j = 0; j < arr[i].length; j++) {\r\n                    for (let k = 0; k < arr[i][j].length; k++) {\r\n                        if (arr[i][j][k]) {\r\n                            console.log(`[${i}][${j}][${k}] = ${arr[i][j][k]!.id}`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // debug function. Delete when no needed.\r\n    public render(scene: THREE.Scene) {\r\n        // render all the assets in the scene.\r\n        for (let i = 0; i < this.sets.length; i++) {\r\n            const set = this.sets[i];\r\n            console.log(set);\r\n            const arr = set.matrix.matrix;\r\n            for (let i = 0; i < arr.length; i++) {\r\n                if (arr[i]) { // Check if the row is defined\r\n                    for (let j = 0; j < arr[i].length; j++) {\r\n                        for (let k = 0; k < arr[i][j].length; k++) {\r\n                            if (arr[i][j][k] !== null) {\r\n                                // render the asset\r\n                                set.placeAsset(arr[i][j][k]!, i, j, k, this.grid, scene);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // the idea is manager all the assets in the scene.\r\n}\r\n\r\nexport enum Direction {\r\n    FRONT = \"front\",\r\n    BACK = \"back\",\r\n    LEFT = \"left\",\r\n    RIGHT = \"right\"\r\n}\r\n\r\nconst directionMap = {\r\n    [Direction.FRONT]: { x: 1, z: 0 },\r\n    [Direction.BACK]: { x: -1, z: 0 },\r\n    [Direction.LEFT]: { x: 0, z: -1 },\r\n    [Direction.RIGHT]: { x: 0, z: 1 },\r\n};\r\n\r\nfunction updateNewPosition(direction: Direction, indx: number, indz: number) {\r\n    if (direction) {\r\n        indx += directionMap[direction].x;\r\n        indz += directionMap[direction].z;\r\n    }\r\n    return { indx, indz };\r\n}\r\n\r\nexport interface Set {\r\n    name: string;\r\n    matrix: NMatrix<Asset>;\r\n    add(newasset: {\r\n        col: number;\r\n        floor: number;\r\n        row: number;\r\n        grid: EventGrid;\r\n        direction1: Direction;\r\n        direction2?: Direction;\r\n        gap?: number;\r\n    }): void;\r\n\r\n    placeAsset(asset: Asset, x: number, y: number, z: number, grid: EventGrid, scene: THREE.Scene): void;\r\n\r\n    hasAssetInPosition(x: number, y: number, z: number): boolean;\r\n}\r\n\r\nexport class Set implements Set {\r\n    name: string;\r\n    matrix: NMatrix<Asset>;\r\n    sideMatrix: NMatrix<{loc1: Side; loc2: Side}>; \r\n\r\n    constructor(name: string, grid: EventGrid, initialAsset?: Asset) {\r\n        this.name = name;\r\n        this.matrix = new NMatrix<Asset>(grid.cols, grid.floor, grid.rows, null);\r\n        if (initialAsset) {\r\n            this.matrix.matrix[initialAsset.x][initialAsset.y][initialAsset.z] = initialAsset;\r\n        }\r\n        this.sideMatrix = new NMatrix<{loc1: Side; loc2: Side}>(grid.cols, grid.floor, grid.rows, {loc1: Side.CENTER, loc2: Side.BOTTOM});\r\n    }\r\n\r\n    public add(oldasset: {\r\n        col: number;\r\n        floor: number;\r\n        row: number;\r\n        grid: EventGrid;\r\n        direction1: Direction;\r\n        direction2?: Direction;\r\n        gap?: number;\r\n    }) : Asset | null {\r\n\r\n        if (this.matrix.matrix[oldasset.col][oldasset.floor][oldasset.row] === null) {\r\n            throw new Error('The asset is not in the grid');\r\n        }\r\n        if (oldasset.direction1 === oldasset.direction2) {\r\n            throw new Error('Direction1 and Direction2 cannot be the same');\r\n        }\r\n        let newasset: Asset;\r\n\r\n        newasset = this.matrix.matrix[oldasset.col][oldasset.floor][oldasset.row]!.clone();\r\n\r\n        if (oldasset.gap) {\r\n            throw new Error('The gap is not implemented yet');\r\n            // logic for when there is a gap. I will put this to further into the project because it take a little bit more effort, but it would cool to be able to get out of the grid to acommodate the assets based on some custom gap.\r\n        }\r\n\r\n        else {\r\n            let indx = newasset.x;\r\n            let indz = newasset.z;\r\n\r\n\r\n\r\n            ({ indx, indz } = updateNewPosition(oldasset.direction1!, indx, indz));\r\n            \r\n            if (oldasset.direction2)\r\n                ({ indx, indz } = updateNewPosition(oldasset.direction2, indx, indz));\r\n\r\n\r\n            if (indx < 0 || indx >= this.matrix.cols || indz < 0 || indz >= this.matrix.rows) {\r\n                throw new Error('The asset is out of the grid');\r\n            }\r\n\r\n            // here we update the x and y according to the new position. This can be improved by restructuring what has the resopnsability to update the position. Because one can forget to update the x and y of the asset.\r\n            newasset.x = indx;\r\n            newasset.z = indz;\r\n\r\n            this.matrix.matrix[indx][newasset.y][indz] = newasset;\r\n            this.matrix.matrix[indx][newasset.y][indz]!.x = indx;\r\n            this.matrix.matrix[indx][newasset.y][indz]!.z = indz;\r\n\r\n            return this.getAsset(indx, newasset.y, indz);\r\n        }\r\n    }\r\n\r\n    public getAsset(x: number, y: number, z: number) {\r\n        return this.matrix.matrix[x][y][z];\r\n    }\r\n\r\n    public placeAsset(asset: Asset, x: number, y: number, z: number, grid: EventGrid, scene: THREE.Scene) {\r\n        grid.placeAssetTo(asset, x, y, z, this.sideMatrix.matrix[x][y][z]!.loc1, this.sideMatrix.matrix[x][y][z]!.loc2);\r\n        scene.add(asset.content);\r\n    }\r\n\r\n    public hasAssetInPosition(x: number, y: number, z: number): boolean {\r\n        let occupiedByAsset = false;\r\n        this.matrix.forEach((value, _i, _j, _k) => {\r\n            if (value !== null && value.x === x && value.y === y && value.z === z) {\r\n                occupiedByAsset = true;\r\n            }\r\n        });\r\n        return occupiedByAsset;\r\n    }\r\n}\r\n\r\nexport class ChairSet extends Set {\r\n\r\n    constructor(name: string, grid: EventGrid, initialChair?: Chair) {\r\n        if (initialChair) {\r\n            super(name, grid, initialChair);\r\n        }\r\n        else {\r\n            super(name, grid);\r\n        }\r\n    }\r\n\r\n    // remove the scene from the parameters. The final rendering should be set in another function. \r\n    public override placeAsset(asset: Asset, x: number, y: number, z: number, grid: EventGrid, scene: THREE.Scene) {\r\n        grid.placeAssetTo(asset, x, y, z, this.sideMatrix.matrix[x][y][z]!.loc1, this.sideMatrix.matrix[x][y][z]!.loc2);\r\n        scene.add(asset.content);\r\n    }\r\n\r\n    public override add(oldasset: {\r\n        col: number;\r\n        floor: number;\r\n        row: number;\r\n        grid: EventGrid;\r\n        direction1: Direction;\r\n        direction2?: Direction;\r\n        gap?: number\r\n    }) : Asset | null {\r\n        // add the logic for the gap.\r\n        const result = super.add(oldasset);\r\n        if (result!.size.width > (oldasset.grid.width / oldasset.grid.cols) || result!.size.depth > (oldasset.grid.depth / oldasset.grid.rows)) {\r\n\r\n            if (oldasset.col === 0 && (oldasset.direction1 === Direction.FRONT || oldasset.direction2 === Direction.FRONT)) {\r\n                this.sideMatrix.change({loc1: Side.BOTTOM, loc2: Side.BACK});\r\n            }\r\n\r\n            const assetwidth = result!.size.width;\r\n            const assetdepth = result!.size.depth;\r\n\r\n            this.matrix.matrix[result!.x][result!.y][result!.z] = null;\r\n            \r\n            const offsetx = Math.floor(assetwidth / (oldasset.grid.width / oldasset.grid.cols));\r\n            const offsetz = Math.floor(assetdepth / (oldasset.grid.depth / oldasset.grid.rows));\r\n\r\n            let x = result!.x;\r\n            if (oldasset.direction1 === Direction.FRONT || oldasset.direction2 === Direction.FRONT) {\r\n                x = result!.x + offsetx;\r\n            }\r\n\r\n            const z = result!.z + offsetz;\r\n            // here we update the x and y according to the new position. This can be improved by restructuring what has the resopnsability to update the position. Because one can forget to update the x and y of the asset.\r\n            result!.x = x;\r\n            result!.z = z;\r\n\r\n            this.matrix.matrix[x][oldasset.floor][z] = result!.clone();\r\n\r\n            return result;\r\n        }\r\n\r\n        //result!.content.scale.set(0.34, 1, 1);\r\n        return null;\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}